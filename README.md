# 미션 - 다리건너기

## 프로그램 소개

(빠른 이해를 위한 오징어 게임 - 징검다리 편 https://www.youtube.com/watch?v=JUrErvCiPDc
잔인하므로 주의해주세요)

1. 건널 다리의 길이를 입력합니다.
2. 다리의 위 아래중 어느 쪽으로 건널지 선택합니다.
3. 떨어지지 않았다면 다음 다리를 어느 쪽으로 건널지 선택합니다.
4. 떨어졌다면 처음부터 다시 시작합니다. 이때 건널 다리는 기존에 생성된 다리입니다.
5. 게임 종료(중도 포기 or 완주)시 총 시도 횟수와 다리의 모양을 보여줍니다.

## 신경 쓴 부분

이번에는 mvc 패턴을 처음 알게되어 이를 신경 써서 설계했습니다.

다만 정말 처음 알게된 방법이라 미숙합니다.
크게 나눠 뷰 -> 뷰 인터페이스 -> 컨트롤러 <- 모델 인터페이스 <- 모델 과 같은 설계를 만들었습니다.
컨트롤러가 뷰와 모델을 직접 참조하지 않도록 사이에 인터페이스를 넣었습니다.

인터페이스의 개념을 완벽하게 이해하지 못해서, 주어진 API인 MissionUtils 라이브러리에서 제공하는 Console API의 파일 구조를 참고했습니다.

이 파일 내부에는 Console, Random의 로직을 담당하는 각각의 파일이 있고, 이 파일을 하나로 뭉쳐둔 index파일이 있습니다. 이 파일이 있으므로 우리가 내부 각각에 파일에 접근하지 않고 하나의 변수로 모두를 사용할 수 있는 것입니다. 이것과 유사하게 뷰, 모델 인터페이스를 짜려고 노력했습니다.

다만 제가 짠 구조가 한 눈에 봐도 좋은 구조가 아닙니다. 같은 이름의 메서드가 인터페이스에 그대로 존재하므로, 사용하는 컨트롤러 측면에서는 간편하지만, 유지보수하는 측면에서는 굉장히 비효율적인 방법입니다. 왜냐면 인터페이스의 메서드가 어떤 파일에 존재하는지 판단하기도 쉽지않고, 만약 모델쪽 메서드가 수정된다면 인터페이스의 메서드도 수정해야하기 때문입니다. 만약 메서드가 수백개라면 수정하기 쉽지 않겠습니다.

그럼 어떻게 해야 사용도 유지보수도 간편할까 생각해봤지만 설계가 생각나지 않았습니다. 패턴에 익숙하지 않은 상태에서 또 추가적인 걸 생각하자니 조금 힘들어서, 일단은 기능 구현에 초점을 잡고 어떻게든 돌아가며 요구 사항을 만족시키는 것에 집중했습니다.

예외를 잡아서 무엇을 할지에 대한 방법은 여러 방법이 있었지만 가장 직관적이고 간단한 try catch를 이용해서 입력시 오류를 잡아 다시 입력을 받도록 작성했습니다.

## 프로그램 실행 모습

```
다리 건너기 게임을 시작합니다.

다리의 길이를 입력해주세요.
3

이동할 칸을 선택해주세요. (위: U, 아래: D)
U
[ O ]
[   ]

이동할 칸을 선택해주세요. (위: U, 아래: D)
U
[ O | X ]
[   |   ]

게임을 다시 시도할지 여부를 입력해주세요. (재시도: R, 종료: Q)
R
이동할 칸을 선택해주세요. (위: U, 아래: D)
U
[ O ]
[   ]

이동할 칸을 선택해주세요. (위: U, 아래: D)
D
[ O |   ]
[   | O ]

이동할 칸을 선택해주세요. (위: U, 아래: D)
D
[ O |   |   ]
[   | O | O ]

최종 게임 결과
[ O |   |   ]
[   | O | O ]

게임 성공 여부: 성공
총 시도한 횟수: 2
```
