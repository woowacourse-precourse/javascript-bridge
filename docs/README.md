# 미션 - 다리 건너기

## 요구 사항

### 진행방식에 대하여

- [x] 클래스(객체)를 분리하는 연습
- [x] 리팩터링

### 구체적인 코드 작성법에 대하여

- [x] indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
- [x] Jest를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
- [x] else를 지양한다.
- [x] 도메인 로직에 단위 테스트를 구현해야 한다.
- [x] 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- [x] 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
- [x] 메서드의 파라미터 개수는 최대 3개까지만 허용한다.
- [x] 아래 있는 InputView, OutputView, BridgeGame, BridgeMaker 클래스(또는 객체)의 [요구사항](https://github.com/unsnruu/javascript-bridge#%EC%B6%94%EA%B0%80%EB%90%9C-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD)을 참고하여 구현한다.

### 기능과 관련하여

- [x] 게임 시작 문구를 출력하는 UI 메서드 생성하기
- [x] 사용자에게 생성할 다리 길이를 묻는 UI 메서드 생성하기
- [x] 3~20까지의 숫자인지를 validation하기
- [x] 라운드마다 사용자가 이동할 칸을 묻는 UI 메서드 생성하기
- [x] U와 D가 아닌지 validation 하기
- [x] 게임 종료를 출력하는 UI 메서드 생성하기
- [x] 게임시작/종료 여부를 입력받는 UI 메서드 생성하기
- [x] R/Q가 아닌경우 예외처리를 하기
- [x] 모든 예외 처리의 경우, 메세지를 보여주고 다시 그 상태에서 실행하게끔 만들기

### InputView와 OutputView에 대해서

- [x] 두 객체 모두 `woowacourse/mission-utils`를 활용하기.
- [x] Input의 경우 내부적으로 모든 로직을 처리하지 말고 next라는 함수를 통해서 다음 행동을 구현하게끔 로직 구성하기.

### BrideMaker과 관련하여

- [x] BridgeMaker은 사이즈(size)와 0,1를 임의로 생성하는 함수(generateRandomNumber)를 인자로 받기.
- [x] 인자로 받은 사이즈만큼 '반복'을 통해서 다리의 모양을 'U,D'로 이루어진 string 배열로 반환하기.

### BridgeGame과 관련하여

- [x] answer을 프로퍼티로 가지고 있게끔 구현
- [x] start -> move -> retry -> end 의 순서대로 구현
- [x] move의 과정을 나누어서 구현 (move / moveAfter: 입력 값에 대하여 여러 가능성의 분기를 처리)
- [x] restart를 구현: 다시 시작시 입력값, 게임 횟수와 단계를 재설정
- [x] moveAfter 내부에서도 정답시 / 오답시를 나눠어서 메서드화

## 구현 전략

- 자바스크립트가 함수를 일급객체로 취급한다는 점을 이용해서 다음에 실행될 함수를 넘겨서 차례대로 실행시켜볼까 싶습니다. 그렇지만 이럴 경우에 callback hell 현상이 발생할 것으로 예상됩니다.

```
함수를 인자로 받는 과정을 지켜나가다 보니 생각보다는 깊은 depth가 나오지 않았습니다. 때에 따라서는 함수의 길이와 역할의 분리를 더욱 깔끔하게 해주었습니다. 대표적으로는 OutputView의 메소드를 해당 방식을 사용해서 구현하였습니다.
```

- 다리가 정답을 어떤 식으로 비교하는지 전략을 적었습니다.

```
   * 1. 사용자가 입력한 값이 "U"이다.
   *  1.1 사용자가 입력한 값과 정답이 일치한다.
   *  1.2 사용자가 입력한 값과 정답이 일치하지 않는다.
   * 2. 사용자가 입력한 값이 "D"이다.
   *  2.1 사용자가 입력한 값과 정답이 일치한다.
   *  2.2 사용자가 입력한 값과 정답이 일치하지 않는다.
```

- 최종 게임 결과물 출력에 대한 전략을 적었습니다.

```
   * 최종게임 결과를 출력하려면
   * 1. 성공/실패 여부와
   * 2. 총 시도한 횟수와
   * 3. 게임 맵(answer,input)을 가져와야한다.*
   * => 그럼 총 네개의 인자를 가져와야하는데 어떻게 해야할까.*
   * 실패여부를 answer과 input을 비교하여서 계산해낼 수 있지 않을까?
```

## 이슈

1. this 바인딩이 동적으로 일어나기 때문에 구조분해할당을 통한 메서드의 사용이
   실패하는 문제를 겪었습니다. 이론으로만 터득한 지식을 실제로 적용했을 떄는 잊어 버리기 쉽다는 사실을 다시 배울 수 있었습니다. (9e418ba)

## 후기

- 3주차에서 클래스를 분리하는 연습을 잘하지 못했던 것 같습니다. 이번 미션에서는 일단 클래스를 잘 분리하는 것을 우선조건으로 삼아서 진행해 보려고 합니다. 또한 커밋 컨벤션을 좀 더 잘 지켜서 작성해보려고 하였습니다.
- 10줄 이하로 코드를 강제하는 요구사항은 강제성의 이로움에 대한 깨달음을 주었습니다. 강제성이 코드의 퀄리티를 높이는 데 도움이 될 수 있다는 사실이었습니다. 10줄 이하로 코드를 강제하니 어떻게 하면 가독성을 높이고 코드의 기능을 간결하게 할 수 있을지 고민할 수 있는 시간을 갖게 되었습니다. 코드에 대해서 오래 생각하고 교차적으로 지식을 활용하도록 노력하였습니다.
- 이번 미션은 특히나 자바스크립는 정말 다양한 지식을 활용할 수 있는 언어라는 것을 체험할 수 있엇습니다. OOP를 지향하여 클래스와 객체로 기능을 분리하는 것이 뿌듯한 일이었습니다. 거기에 더해서 자그만한 함수형 프로그래밍 기법을 더해보았는데 모처럼 잘 풀려서 다행이라는 기분을 느꼈습니다.
- eslint를 왜 저번 과제에서는 안썼는지 아쉬움이 남습니다. 마지막 과제인 만큼 할 수 있는 방법을 모두 동원해서 구현해보자고 노력했습니다.
- 문제의 요구사항에서 `BridgeGame 클래스에서 InputView, OutputView 를 사용하지 않는다.`는 문장을 뒤늦게 발견하게 되었습니다. 때문에 리팩토링(?)을 강제로 진행하게 되었습니다. 다행히 추상화를 잘 해 놓았다고 생각합니다. 역할의 분리와 코드간의 의존성을 줄이니 변경이 쉬웠습니다. 다만 문제의 의도에 대해서 다시 생각해 보게 되었습니다. BridgeGame을 객체답게 사용하고 독립성을 유지하여 최종적으로는 테스트가 가능하도록 짜는 게 목적이 아니었나 하는 생각이 들었습니다. 하지만 이를 어떻게 잘 풀어나갈 수 있을지는 조금 더 고민해 보아야겠습니다.
- 돌이켜 보면 ADT(Abstract Data Type)처럼 미리 파일의 구조가 어느 정도 정해졌다는 사실이 구현에 용이하게 작용했습니다. 오브젝트 간의 역할을 –비록 처음엔 오해했지만- 명시해 놓으니 코드를 구현할 때 방향성을 찾기도 수월했습니다. OOP에 대해서 그간 익숙해지지 않았는데 이번 계기로 조금이나마 가까워졌다고 느꼈습니다.
- 테스트 코드는 리팩토링을 위한 선행과정임을 느꼈습니다. 이번 미션에서는 코드를 많이 고치고 옮기기를 반복했는데, 그때마다 테스트를 통해서 제대로 어플리케이션이 작동하는 지를 확인할 수 있어서 좋았습니다.
- 결론적으로 조금씩 구현 사항을 지켜가는 제 자신을 보면서 서서히 발전해 나갈수 있다는 자신감을 얻게 되었습니다.
