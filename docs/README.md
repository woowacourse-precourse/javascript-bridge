## 기능구현 요구사항

#### 입력값 에러처리에 관한 부분
* 다리길이 : 다리길이는 숫자 type이여야 하고, 3이상 20이하의 숫자만 입력받음.
* 플레이어 이동문자 : U,D 중 하나의 문자를 입력 할 수 있음. 
* 게임 다시시작 문자 : R,Q 중 하나의 문자가 아니면 예외처리 한다.
* 각 에러를 처리하는 부분에서는 에러를 던지고 프로그램이 종료되면 안됨.
* 비동기 함수에서는 try.. catch문을 사용 할 수 없기 때문에, Validation하는 함수에서 try..catch를 통해 에러를 핸들링함. 
* try... catch문을 통해 에러메세지를 출력한 후 입력을 다시 받도록 만든다.



### 기능구현함수들
<hr/>
<br/>

#### 1.InputView 객체에서 다리길이를 입력받는 함수를 만든다.<br/>
* Console.readLine을 이용해 다리길이를 입력받는다.
* 입력값이 범위에 맞으면 입력값을 바탕으로 bridgeGame객체를 생성한다.
* 이 객체의 참조값을 이후 입력을 받는 함수들에게 넘긴다.

#### 2. 입력된 다리길이를 바탕으로 U와 D로 이루어진 다리를 만든다. <br/>
* 0,1의 무작위 값을 생성할때는 BridgeRandomNumberGenerator를 사용한다.
* 0이라면 D로 1이라면 U로 대응시킨후 U와 D로 이루어진 array를 bridge Class에게 전달한다.

#### 3.bridgeGame class
* Game 진행과 관련된 필드와 메서드들을 선언한다. 
* 현재 bridgeGame의 Index, 게임성공여부, gameCount, bridge 총 4가지 필드를 가진다.
* move 함수는 움직인 방향과 bridge의 현재 인덱스값이 같으면 현재 인덱스를 1증가시키고,
* 다르면 success를 false로 바꾼다.
* retry함수는 bridge를 제외한 필드를 초기화하고, gameCount를 1 증가시킨다.
* gameNotFinished는 게임이 끝나지 않은 조건을 판별한 boolean값을 return한다.
* gameSuccess는 게임이 성공한 조건을 판별한 boolean값을 return한다. 

#### 4. 라운드마다 플레이어가 이동할 칸을 입력받는 입력함수를 만든다.
* 올바른 문자가 아니면 예외처리하고 다시 입력을 받는다.
* 올바른 입력값이면, 입력값을 바탕으로 다리를 건넌다.
* 건넌 결과를 OutputView에 넣는다. 결과는 success, dir에 따라 다르게 저장된다.
* OutputView에서 결과를 출력한다. 출력은 배열을 join함수를 이용해 구현한다.
* next 함수를 통해 조건에 따라 다음에 어떤 함수가 실행될지 결정한다.

#### 5. resolveNext함수에서 게임결과에 따라 다음에 실행될 함수를 결정한다.
* 게임이 끝나지 않았다면, readMoving을 실행한다.
* 게임을 성공했다면, OutView.printResult를 실행한다.
* 나머지 경우는 게임을 실패한 경우이므로, readGameCommand를 실행한다.

#### 6. 게임을 다시 시도할지 여부를 입력받는다.
* 올바른 문자가 아니라면 예외처리하고 다시 입력을 받는다. 
* 입력이 Q라면, 결과를 출력하고 게임을 종료한다.
* 입력이 R이라면, bridgeGame객체의 bridge를 제외한 모든 값과, OutputView에 결과를 담는 배열을 초기화한다.
* 다시 readMoving으로 움직일 방향을 입력받는다.

