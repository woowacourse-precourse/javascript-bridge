# 요구 사항 분석

1. 왼쪽에서 오른쪽으로 진행되는 다리를 건너는 게임.

2. 다리 생성 : 다리의 길이를 입력받아서 다리를 생성한다.

- 다리 길이의 허용 값은 3이상 20이하 숫자.
- 다리를 생성할 때 위 칸과 아래칸 중 건널 수 있는 칸은 0과 1중 무작위 값을 이용하여 정한다.
- 무작위 값이 0이면 아래 칸, 1이면 위 칸이 건널 수 있는 칸
- 예외 처리 (throw Error)
  - 다리 길이의 입력값이 3이상 20이하 숫자가 아닐 때
  - 다리의 칸을 나타내는 무작위 값이 0 또는 1이 아닐 때

3. 플레이어 이동 : 라운드마다 사용자의 입력을 받아서 사용자를 이동시킨다.

- U는 위칸, D는 아래칸 선택
- 예외 처리 (throw Error)
  - 입력된 문자가 1글자가 아닐 때
  - U와 D가 아닌 다른 문자가 들어왔을 때

4. 이동, 중간 결과 처리

- 각 라운드 마다 이동한 칸에 대한 정보 출력
  - 이동한 칸을 건널 수 있으면 O, 건널 수 없으면 X로 표시
  - 예시
  ```
  [ O |   | X ]
  [   | O |   ]
  ```
- 다리를 건너다 실패하면 게임 재시작(R) or 종료(Q)
- 재시작해도 처음에 만든 다리를 그대로 사용
- 예외 처리
  - 게임 재시작/종료 여부의 글자수가 1글자가 아닐 때
  - 게임 재시작/종료 여부의 글자가 R 또는 Q가 아닐 때

5. 최종 게임 결과 처리

- 다리를 모두 건너거나 중간 실패시 종료를 선택하면 게임을 종료한다.
- 게임 성공 여부와 게임 결과의 총 시도한 횟수는 첫 시도를 포함해 게임 종료 시까지 시도한 횟수를 나타냄.

# 기능 목록 및 todo

- [x] 다리 생성하기 (BridgeMaker.js)
- - [x] 다리 생성 시 입력 값 및 무작위 값 유효성 검사
- - [x] 다리 생성 시 발생하는 예외 처리
- [x] 플레이어 이동(move()) 구현하기
- - [x] 플레이어 이동 입력 값 유효성 검사
- - [x] 플레이어 이동 시 발생하는 예외 처리
- - [x] 플레이어 이동 시 각 라운드 결과 출력
- [x] 실패 시 재시작(R)/종료(Q) 입력 받기
- - [x] 실패시 재시작/종료 입력 값 유효성 검사
- [x] 게임 종료시 최종 결과 출력 (게임 성공 여부, 게임 시도 횟수)
- [x] 정상 테스트케이스 추가
- - [x] 1. 다리 생성 테스트
- - [x] 2. 1번에 성공 (1 시도)
- - [x] 3. 1번 실패 / 1번 재시도(R) / 성공 (2 시도)
- - [x] 4. 1번 실패 / 게임 종료(Q) (1 시도)
- - [x] 5. 2번 실패 / 2번 재시도(R) / 성공 (3 시도)
- [x] 예외 테스트케이스 추가
- - [x] 1. 다리 길이 입력값 예외 : 입력 값이 정수 일 때
- - [x] 2. 다리 길이 입력값 예외 : 입력 값이 3부터 20 사이의 수가 아닐 때
- - [x] 3. 다리 길이 입력값 예외 : 입력 값이 3부터 20 사이의 수가 아닐 때
- - [x] 4. 이동 입력값 예외('U', 'D') : 입력 값이 여러 개 일때
- - [x] 5. 이동 입력값 예외('U', 'D') : 입력 값이 U 또는 D가 아닐 때
- - [x] 6. 재시작 예외('R', 'Q') : 입력 값이 R 또는 Q가 아닐 때

- [x] 1차 리팩토링
- [ ] 최종 리팩토링

# 체크리스트

- [x] 인덴트 depth가 3이 넘지 않도록 구현 (2까지만 허용한다)
- [x] 꼭 필요할 때를 제외하고는 else 지양 (early return)
- [x] 각 함수 또는 메서드의 길이가 10라인을 넘지 않도록 구현
- [x] 메서드 파라미터 개수는 최대 3개
- [x] Console.readLine()은 InputView에서만 사용할 것
- [x] BridgeGame 클래스에서 InputView, OutputView를 사용하지 말 것.
- [x] BridgeMaker의 파일 위치 및 시그니처를 변경하지 말 것.

# 신경 쓴 부분

- 디렉토리 구성 (constraints, models, utils, views)
- 체크리스트를 충족하도록 1차 리팩토링
- BridgeMaker에서 InputView, OutputView를 사용하지 않도록 로직 분리

# 4주차 과제 구현 전,중,후 느낀 점

- 1. 구상하기에는 App.js 내에서 함수를 순차적으로 배치하여 입력을 받고, 다리를 만들고, 게임을 진행시키려 했었습니다.. 하지만 자꾸 입력이 끝나기도 전에 다음 함수가 실행이 되어버려서 비동기 처리에 대해 학습하게 되었습니다.

- 2. 기존 과제에서의 제 코드와 우형 프리코스 discussions에서 다른 사람들의 코드를 참고한 결과, 비동기로 처리한 사례를 찾을 수 없었습니다.

- 3. 비동기(async,await 또는 Promise) 방법으로는 해결이 불가능하다고 판단하여, 다른 방법을 찾아나섰습니다.

- 4. 콜백 함수를 연쇄적으로 전달하여 순차적으로 실행되게끔 구현했습니다.

- 5. 기존 과제에서와 달리, 요구사항이 game 클래스로 게임의 진행상황을 관리하고, 입력과 출력은 분리하게끔 되어있어서 처음 구현할 때에는 헤메었지만, 구현을 거듭할수록 코드를 수정할 때 되돌아보기 편하다는 것을 깨달았습니다. 이 과정에서 용도에 맞게 각 클래스나 메소드를 파일로 분리해야하는 이유와 나름의 분리 기준을 이해할 수 있었습니다.

- 6. 아쉬운 점이 있다면 최초 MVC 패턴을 적용하고 싶었으나, 각 모듈들이 MVC 중 어느 역할을 하는지 제대로 이해하지 못해서 완벽하게 적용하지는 못했습니다.

- 7. 주어진 테스트의 runException()에서, throw new ERROR를 잡았을 때 테스트케이스를 통과하지 못하는 현상이 발생했습니다. 같은 에러 상황일 때 throw new ERROR 대신 Console.print("ERROR ~~~")를 했을 때는 테스트케이스를 통과할 수 있었습니다. 테스트 케이스를 통과하려면 Console로 에러를 처리해야하는데, 의도한 코드대로면 throw 로 에러를 처리하는게 맞습니다. 테스트케이스를 입맛대로 새로 작성해볼까도 생각해보았습니다.

- 8. 위 7번 느낀 점에서 발생한 문제를 해결했습니다. 에러 상황 시 throw Error로 끝낼 것이 아니라, 콘솔에서 메시지도 출력해주어야 했습니다. try-catch 문을 통해 에러를 잡아내어 에러의 메시지도 콘솔에 출력하도록 수정하였습니다.

- 9. 코드를 여러번 수정했지만 아직 미흡한 점이 많다고 생각되었습니다. 함수를 더 쪼갤 수 있을 것 같은데? 라는 생각이 가장 많이 들었으며, expect, toEqual, toThrow과 같은 Jest의 메소드를 완벽히 다루지는 못하는 등 테스트 코드 작성 시에도 이해가 되지 않는 부분이 많았습니다. 이번 프리코스 과정에서 많은 개념들을 알아갈 수 있어서 기뻤고, 주어진 문제를 스스로 해결해가는 방법에도 익숙해질 수 있는 시간이었습니다.
