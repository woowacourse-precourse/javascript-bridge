# 4주차 미션 - 🌉 다리 건너기 게임

---

## 게임 흐름

1. `다리의 길이` 를 입력받는다.
2. 입력받은 길이 만큼 이동할 칸을 `[U]Up, [D]Down` 을 입력하여 다리를 건넌다.
3. 성공/실패시 `게임 재시작` 여부를 묻는다.
4. 종료시 `총 시도 횟수`를 보여준다.

## 📃 기능 목록

### # 입력 - `InputView`

#### 1. 다리의 길이를 입력받는다 - `readBridgeSize()`

- [ ] 입력값이 정수인지 확인한다.
- [ ] 입력값의 범위가 3부터 20 사이인지 확인한다.

#### 2. 이동할 칸을 입력받는다 - `readMoving()`

- [ ] 입력값이 `U` 또는 `D`인지 확인한다.

#### 3. 게임의 재시도 여부를 입력받는다 - `readGameCommand()`

- [ ] 입력값이 `R` 또는 `Q`인지 확인한다.

### # 출력 - `OutputView`

#### 1. 게임 시작 메세지를 출력한다 - `printStart()`

#### 2. 현재 다리 상태를 출력한다 - `printMap()`

#### 3. 최종 게임 결과 메세지를 출력한다 - `printResult()`

### # 게임 관리 - `BridgeGame`

#### 1. 사용자가 칸을 이동한다 - `move()`

#### 2. 사용자가 게임을 다시 시작한다 - `retry()`

#### 3. 사용자가 게임을 종료한다 - `end()`

### # 다리 생성 - `BridgeMaker`

#### 1. 사용자가 입력한 숫자만큼 다리를 생성한다 - `makeBridge()`

## 🧭 요구 사항

- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.

- Jest를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
- else를 지양한다.
- 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(Console.readLine, Console.print) 로직에 대한 단위 테스트는 제외한다.
  - 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 구분한다.

### 추가된 요구 사항

- 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
- 메서드의 파라미터 개수는 최대 3개까지만 허용한다.
- 아래 있는 `InputView`, `OutputView`, `BridgeGame`, `BridgeMaker` 클래스(또는 객체)의 요구사항을 참고하여 구현한다.
  - 각 클래스(또는 객체)의 제약 사항은 아래 클래스별 세부 설명을 참고한다.
  - 이외 필요한 클래스(또는 객체)와 메서드는 자유롭게 구현할 수 있다.
  - `InputView` 에서만 `MissionUtils`의 `Console.readLine()` 을 이용해 사용자의 입력을 받을 수 있다.
  - `BridgeGame` 클래스에서 `InputView`, `OutputView` 를 사용하지 않는다.

### InputView 객체

- 제공된 `InputView` 객체를 활용해 구현해야 한다.
- `InputView`의 파일 경로는 변경할 수 있다.
- `InputView`의 메서드의 인자는 변경할 수 있다.
- 사용자 값 입력을 위해 필요한 메서드를 추가할 수 있다.

### OutputView 객체

- 제공된 `OutputView` 객체를 활용해 구현해야 한다.
- `OutputView`의 파일 경로는 변경할 수 있다.
- `OutputView`의 메서드의 이름은 변경할 수 없고, 인자는 필요에 따라 추가하거나 변경할 수 있다.
- 값 출력을 위해 필요한 메서드를 추가할 수 있다.

### BridgeGame 클래스

- 제공된 `BridgeGame` 클래스를 활용해 구현해야 한다.
- `BridgeGame`에 필드(인스턴스 변수)를 추가할 수 있다.
- `BridgeGame`의 파일 경로는 변경할 수 있다.
- `BridgeGame`의 메서드의 이름은 변경할 수 없고, 인자는 필요에 따라 추가하거나 변경할 수 있다.
- 게임 진행을 위해 필요한 메서드를 추가 하거나 변경할 수 있다.

### BridgeMaker 객체

- 제공된 `BridgeMaker` 객체를 활용해 구현해야 한다.
- `BridgeMaker`에 프로퍼티를 추가할 수 없다.
- `BridgeMaker`의 파일 경로는 변경할 수 없다.
- `BridgeMaker`의 메서드의 시그니처(인자, 이름)와 반환 타입은 변경할 수 없다.

### BridgeRandomNumberGenerator 객체

- Random 값 추출은 제공된 `BridgeRandomNumberGenerator`의 `generate()`를 활용한다.
- `BridgeRandomNumberGenerator`의 코드는 변경할 수 없다.

## 🎯 목표(공통 피드백)

- 1주차
  - 요구사항을 정확히 준수한다.
  - 커밋 메시지를 의미 있게 작성한다.
  - git 을 통해 관리할 자원에 대해서도 고려한다.
  - Pull Request를 보내기 전 브랜치를 확인한다.
  - PR을 한 번 작성했다면 닫지 말고 추가 커밋을 한다.
  - 이름을 통해 의도를 드러낸다.
  - 축약하지 않는다.
  - 공백도 코딩 컨벤션이다.
  - 공백 라인을 의미 있게 사용한다.
  - space와 tab을 혼용하지 않는다.
  - 의미 없는 주석을 달지 않는다.
  - linter와 Code Formatter의 기능을 활용한다.
  - EOL (End of Line)
  - 불필요한 console.log 를 남기지 않는다.
  - JavaScript에서 제공하는 API를 적극 활용한다.
- 2주차
  - README.md를 상세히 작성한다.
  - 기능 목록을 재검토한다.
  - 기능 목록을 업데이트한다.
  - 값을 하드 코딩하지 않는다.
  - 구현 순서도 코딩 컨벤션이다.
  - 한 함수가 한 가지 기능만 담당하게 한다.
  - 함수가 한 가지 기능을 하는지 확인하는 기준을 세운다.
  - JavaScript에서 객체를 만드는 다양한 방법을 이해하고 사용한다.
  - 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다.
  - 처음부터 큰 단위의 테스트를 만들지 않는다.
- 3주차
  - 함수(메서드)의 길이가 15라인을 넘어간다면 분리를 위한 고민을 한다.
  - 발생할 수 있는 예외 상황에 대해 고민한다
  - 비즈니스 로직과 UI 로직을 분리한다
  - 객체의 상태 접근을 제한한다
  - 객체는 객체스럽게 사용한다
  - 필드의 수를 줄이기 위해 노력한다
  - 성공하는 케이스 뿐만 아니라 예외에 대한 케이스도 테스트한다
  - 테스트 코드도 코드다
  - 테스트를 위한 코드는 구현 코드에서 분리되어야 한다
  - 단위 테스트하기 어려운 코드를 단위 테스트하기
