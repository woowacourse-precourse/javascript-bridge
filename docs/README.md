# 우아한테크코스 4주차 미션 - 다리 건너기

## 0. 미리보기

![게임 구조](./%EB%8B%A4%EB%A6%AC_%EA%B1%B4%EB%84%88%EA%B8%B0_%EA%B5%AC%EC%A1%B0.png)

## 1. 기능

### 1. 실행 결과 예시를 이용한 기능 분리

1. 게임 시작 출력

```
다리 건너기 게임을 시작합니다.
```

2. 길이를 입력받는다.

```
다리의 길이를 입력해주세요.
3
```

3. 이동할 칸 입력을 받고 연산한 뒤 결과를 출력한다.

```
이동할 칸을 선택해주세요. (위: U, 아래: D)
U
[ O ]
[ ]
```

4. 연산 결과가 X인지 판단하고 재시도 입력을 받는다.

```
게임을 다시 시도할지 여부를 입력해주세요. (재시도: R, 종료: Q)
R
```

5. 게임이 끝난 경우 게임 결과를 출력한다.

```
최종 게임 결과
[ O | | ]
[ | O | O ]
```

6. 게임 통계를 출력한다.

```
게임 성공 여부: 성공
총 시도한 횟수: 2
```

### 2. 프로그램 흐름의 틀

1. InputView.readBridgeSize
   1. 다리 길이를 받는다
   2. 입력값을 검증한다
   3. 검증한 값이 올바르면 Controller.makeBridgeGame에 값을 넘겨 인스턴스를 받는다
   4. this.readMoving 함수에 인스턴스를 넘겨준다
2. InputView.readMoving
   1. 이동할 칸을 받는다
   2. 입력값을 검증한다
   3. Controller.sendUserMoving 메소드에 입력값과 인스턴스를 넘겨준다
      1. bridgeGame.move 함수에 입력값을 넘겨주고 결과 메시지를 받는다
      2. bridgeGame.makeMap 함수로 맵을 생성해 OutputView 객체에 전달, 맵을 출력한다.
      3. 만약 결과 메시지가 게임 클리어라면
         1. bridgeGame 게임 통계를 만들어
         2. OutputView 객체에 전달해 최종 결과를 출력한다
      4. 결과 메시지를 반환한다.
   4. 만약 결과 메시지가 게임 오버라면 this.readGameCommand 함수를 반환한다.
   5. 만약 결과 메시지가 게임 클리어라면 함수를 종료한다.
   6. this.readMoving을 호출한다.
3. InputView.readGameCommand
   1. 게임 재시도 여부를 받는다
   2. 입력값을 검증한다
   3. 컨트롤러에 입력값과 인스턴스를 보낸 뒤, 결과 값을 받는다
      1. 인스턴스에 입력값을 넣어 재시도 여부를 결과로 받는다.
      2. 만약 반환값이 종료이면
         1. 맵을 만들고
         2. 통계를 만들고
         3. OutputView.printResult 함수에 맵과 통계를 전달해 출력한다.
      3. 재시도 여부를 반환한다.
   4. 만약 결과 값이 재시도이면 this.readMoving을 호출한다.

## 2. 학습 과정

### 1. 고민했던 내용들

1. 반환값을 실사용하지 않는 경우 테스트를 위해 반환값을 만들어줘야 하는가?

- 기능을 세분화하니 테스트가 가능한 메소드가 나타났다.

2. 객체 또는 클래스를 선정하는 기준이 있는가?

- 콜백을 사용해 문제를 해결하는 경우, 클래스로 구성했을 때 인스턴스를 전달해주지 않으면 처음에 생성한 인스턴스와 나중에 생성한 인스턴스가 다르다. 이러한 문제가 발생이 되는 경우 객체로 정의하는 것이 낫다.

3. [v] BridgeGame 인스턴스를 넘겨주는 것 vs 새 BridgeGame 인스턴스를 생성하는 것

- 재시도마다 새 인스턴스를 생성하는 것은 가비지 콜렉팅 관점에서 지양해야 할 방법이다.
- 게임 스테이지 같은 사례로 생각하면 재시도마다 똑같은 값을 가진 스테이지가 생성되는 것은 자원 낭비이다.
- 따라서 기존 인스턴스를 넘겨주는 것으로 구현했다.

4. 클래스나 객체는 상호 참조가 불가능한가?

- 가능하면 하지 않는 편이 좋다.

5. 객체 구분하는 기준

- 반복적으로 호출하거나 호출 공간이 여러 곳인 경우 클래스보다 객체로 구현하자.

6. 변수 두 번 선언 vs 목적과 다른 메소드에 선언

- 구조가 잘못되진 않았는지 다시 생각해보자.

7. OutputView 객체의 메소드를 호출하는 객체 또는 클래스가 달라도 되는가? X
   - InputView에서 직접 호출하면 BridgeGame 인스턴스를 인자로 보내고, BridgeGame 인스턴스 메소드에서 호출하면 필드값과 메소드 결과값을 보낸다
   - 즉, 호출하는 위치에 따라 호출 방식이 달라지므로 이는 옳지 않다고 판단, 인스턴스를 인자로 보내기로 했다. => 시도해보니 이런 방법은 더 어울리지 않는다.
   - 모든 로직을 BridgeGame 클래스 내에서 처리하고, InputView는 입력 값 검증 + 보내기만 / OutputView는 값을 받아 출력하기만 구현할 예정
   1. Views, BridgeGame만 있다면 InputView에서 OutputView를 호출해야 하므로 한 역할만 할 수 없게 된다.
   2. controller 객체를 만들어 중간 값을 관리하는 것이 좋지 않을까? 의존성 문제는 있겠지만..

### 2. 궁금한 점

1. 큰 함수 ~ 작은 함수로 크기 순 나열 vs 한 함수에서 호출되는 함수들을 모은 단위로 나열
2. 함수를 구현하기 위해 필요한 작은 함수는 클래스 또는 객체가 아닌 다른 곳에 정의하는 것이 바람직한가?
