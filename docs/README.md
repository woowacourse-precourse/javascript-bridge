# 요구 사항 분석

1. 왼쪽에서 오른쪽으로 진행되는 다리를 건너는 게임.

2. 다리 생성 : 다리의 길이를 입력받아서 다리를 생성한다.

- 다리 길이의 허용 값은 3이상 20이하 숫자.
- 다리를 생성할 때 위 칸과 아래칸 중 건널 수 있는 칸은 0과 1중 무작위 값을 이용하여 정한다.
- 무작위 값이 0이면 아래 칸, 1이면 위 칸이 건널 수 있는 칸
- 예외 처리 (throw Error)
  - 다리 길이의 입력값이 3이상 20이하 숫자가 아닐 때
  - 다리의 칸을 나타내는 무작위 값이 0 또는 1이 아닐 때

3. 플레이어 이동 : 라운드마다 사용자의 입력을 받아서 사용자를 이동시킨다.

- U는 위칸, D는 아래칸 선택
- 예외 처리 (throw Error)
  - 입력된 문자가 1글자가 아닐 때
  - U와 D가 아닌 다른 문자가 들어왔을 때

4. 이동, 중간 결과 처리

- 각 라운드 마다 이동한 칸에 대한 정보 출력
  - 이동한 칸을 건널 수 있으면 O, 건널 수 없으면 X로 표시
  - 예시
  ```
  [ O |   | X ]
  [   | O |   ]
  ```
- 다리를 건너다 실패하면 게임 재시작(R) or 종료(Q)
- 재시작해도 처음에 만든 다리를 그대로 사용
- 예외 처리
  - 게임 재시작/종료 여부의 글자수가 1글자가 아닐 때
  - 게임 재시작/종료 여부의 글자가 R 또는 Q가 아닐 때

5. 최종 게임 결과 처리

- 다리를 모두 건너거나 중간 실패시 종료를 선택하면 게임을 종료한다.
- 게임 성공 여부와 게임 결과의 총 시도한 횟수는 첫 시도를 포함해 게임 종료 시까지 시도한 횟수를 나타냄.

# 기능 목록 및 todo

- [x] 다리 생성하기 (BridgeMaker.js)
- - [x] 다리 생성 시 입력 값 및 무작위 값 유효성 검사
- - [x] 다리 생성 시 발생하는 예외 처리
- [x] 플레이어 이동(move()) 구현하기
- - [x] 플레이어 이동 입력 값 유효성 검사
- - [x] 플레이어 이동 시 발생하는 예외 처리
- - [x] 플레이어 이동 시 각 라운드 결과 출력
- [x] 실패 시 재시작(R)/종료(Q) 입력 받기
- - [x] 실패시 재시작/종료 입력 값 유효성 검사
- [x] 게임 종료시 최종 결과 출력 (게임 성공 여부, 게임 시도 횟수)
- [x] 정상 테스트케이스 추가
- - [x] 1. 다리 생성 테스트
- - [x] 2. 1번에 성공 (1 시도)
- - [x] 3. 1번 실패 / 1번 재시도(R) / 성공 (2 시도)
- - [x] 4. 1번 실패 / 게임 종료(Q) (1 시도)
- - [x] 5. 2번 실패 / 2번 재시도(R) / 성공 (3 시도)
- [x] 예외 테스트케이스 추가
- - [x] 1. 다리 길이 입력값 예외 : 입력 값이 정수 일 때
- - [x] 2. 다리 길이 입력값 예외 : 입력 값이 3부터 20 사이의 수가 아닐 때
- - [x] 3. 다리 길이 입력값 예외 : 입력 값이 3부터 20 사이의 수가 아닐 때
- - [x] 4. 이동 입력값 예외('U', 'D') : 입력 값이 여러 개 일때
- - [x] 5. 이동 입력값 예외('U', 'D') : 입력 값이 U 또는 D가 아닐 때
- - [x] 6. 재시작 예외('R', 'Q') : 입력 값이 R 또는 Q가 아닐 때

- [x] 1차 리팩토링
- [ ] 최종 리팩토링

# 체크리스트

- [x] 인덴트 depth가 3이 넘지 않도록 구현 (2까지만 허용한다)
- [x] 꼭 필요할 때를 제외하고는 else 지양 (early return)
- [x] 각 함수 또는 메서드의 길이가 10라인을 넘지 않도록 구현
- [x] 메서드 파라미터 개수는 최대 3개
- [x] Console.readLine()은 InputView에서만 사용할 것
- [x] BridgeGame 클래스에서 InputView, OutputView를 사용하지 말 것.
- [x] BridgeMaker의 파일 위치 및 시그니처를 변경하지 말 것.

# 신경 쓴 부분

- 디렉토리 구성 (constraints, models, utils, views)
- 체크리스트를 충족하도록 1차 리팩토링
- BridgeMaker에서 InputView, OutputView를 사용하지 않도록 로직 분리

# 4주차 과제 구현 전,중,후 느낀 점

- 1. 구상하기에는 App.js 내에서 함수를 순차적으로 배치하여 입력을 받고, 다리를 만들고, 게임을 진행시키려 했었습니다.. 하지만 자꾸 입력이 끝나기도 전에 다음 함수가 실행이 되어버려서 비동기 처리에 대해 학습하게 되었습니다.

- 2. 기존 과제에서의 제 코드와 우형 프리코스 discussions에서 다른 사람들의 코드를 참고한 결과, 비동기로 처리한 사례를 찾을 수 없었습니다.

- 3. 비동기(async,await 또는 Promise) 방법으로는 해결이 불가능하다고 판단하여, 다른 방법을 찾아나섰습니다.

- 4. 콜백 함수를 연쇄적으로 전달하여 순차적으로 실행되게끔 구현했습니다.

- 5. 기존 과제에서와 달리, 요구사항이 game 클래스로 게임의 진행상황을 관리하고, 입력과 출력은 분리하게끔 되어있어서 처음 구현할 때에는 헤메었지만, 구현을 거듭할수록 코드를 수정할 때 되돌아보기 편하다는 것을 깨달았습니다. 이 과정에서 용도에 맞게 각 클래스나 메소드를 파일로 분리해야하는 이유와 나름의 분리 기준을 이해할 수 있었습니다.

- 6. 아쉬운 점이 있다면 최초 MVC 패턴을 적용하고 싶었으나, 각 모듈들이 MVC 중 어느 역할을 하는지 제대로 이해하지 못해서 완벽하게 적용하지는 못했습니다.

- 7. 주어진 테스트의 runException()에서, throw new ERROR를 잡았을 때 테스트케이스를 통과하지 못하는 현상이 발생했습니다. 같은 에러 상황일 때 throw new ERROR 대신 Console.print("ERROR ~~~")를 했을 때는 테스트케이스를 통과할 수 있었습니다. 테스트 케이스를 통과하려면 Console로 에러를 처리해야하는데, 의도한 코드대로면 throw 로 에러를 처리하는게 맞습니다. 테스트케이스를 입맛대로 새로 작성해볼까도 생각해보았습니다.

- 8. 위 7번 느낀 점에서 발생한 문제를 해결했습니다. 에러 상황 시 throw Error로 끝낼 것이 아니라, 콘솔에서 메시지도 출력해주어야 했습니다. try-catch 문을 통해 에러를 잡아내어 에러의 메시지도 콘솔에 출력하도록 수정하였습니다.

- 9. 코드를 여러번 수정했지만 아직 미흡한 점이 많다고 생각되었습니다. "함수를 더 쪼갤 수 있을 것 같은데?"라는 생각이 가장 많이 들었으며, expect, toEqual, toThrow과 같은 Jest의 메소드를 완벽히 다루지는 못하는 등 테스트 코드 작성 시에도 이해가 되지 않는 부분이 많았습니다.
     이번 프리코스 과정에서 코스 시작 전엔 신경쓰지 못했던 함수 분리, 컨벤션, 클린코드 등의 다양한 개념으로 유지보수성을 높이는 방법을 알아갈 수 있어서 많이 배웠습니다. 또한 주어진 문제를 스스로 해결해가는 방법에도 익숙해져서, 앞으로의 개발자 생활에 유용하고도 중요한 습관을 배울 수 있었습니다. 좋은 과정 제공해주셔서 감사합니다.

- 10. 제출 후, "예기치 못한 문제가 발생하였습니다." 문구가 자꾸 떠서 제출에 애를 먹었습니다. 원인은 BridgeMaker.js 파일의 경로 문제였습니다. 최초 요구사항 분석을 진행할 때, 해당 파일의 경로를 변경하지 말라는 요구사항을 확인했었는데 코드 구현, 디버깅 진행 과정에서 의도치 않게 수정해버렸습니다. 구현 중, MVC 패턴 적용을 위해 임의로 경로를 변경한 적이 있었는데, 이때 `VSCode의 import 경로 자동 업데이트 기능` 테스트 코드에서 불러오는 경로가 src/models/BridgeMaker로 수정되었었습니다. 당연하게도 그 뒤로 테스트 코드가 정상 작동되지 않았기에, src/models가 바른 위치인 것으로 착각하여 정상 경로에 있던 파일을 다시 models 폴더 내에 옮겼었던 것이 화근이었습니다. 이를 계기로 저는 코드의 변경사항은 아무리 작은 것이라도 꼼꼼하게 확인하고 알고 있어야 한다는 점을 크게 깨달았습니다.
